{"ast":null,"code":"import * as requestFromServer from \"./remarksCrud\";\nimport { remarksSlice, callTypes } from \"./remarksSlice\";\nconst {\n  actions\n} = remarksSlice;\nexport const fetchRemarks = (queryParams, productId) => {\n  return dispatch => {\n    dispatch(actions.startCall({\n      callType: callTypes.list\n    }));\n\n    if (!productId) {\n      return dispatch(actions.remarksFetched({\n        totalCount: 0,\n        entities: null\n      }));\n    }\n\n    return requestFromServer.findRemarks(queryParams, productId).then(response => {\n      const {\n        totalCount,\n        entities\n      } = response.data;\n      dispatch(actions.remarksFetched({\n        totalCount,\n        entities\n      }));\n    }).catch(error => {\n      error.clientMessage = \"Can't find remarks\";\n      dispatch(actions.catchError({\n        error,\n        callType: callTypes.list\n      }));\n    });\n  };\n};\nexport const fetchRemark = id => dispatch => {\n  if (!id) {\n    return dispatch(actions.remarkFetched({\n      remarkForEdit: undefined\n    }));\n  }\n\n  dispatch(actions.startCall({\n    callType: callTypes.action\n  }));\n  return requestFromServer.getRemarkById(id).then(response => {\n    const remark = response.data;\n    dispatch(actions.remarkFetched({\n      remarkForEdit: remark\n    }));\n  }).catch(error => {\n    error.clientMessage = \"Can't find remark\";\n    dispatch(actions.catchError({\n      error,\n      callType: callTypes.action\n    }));\n  });\n};\nexport const deleteRemark = id => dispatch => {\n  dispatch(actions.startCall({\n    callType: callTypes.action\n  }));\n  return requestFromServer.deleteRemark(id).then(response => {\n    dispatch(actions.remarkDeleted({\n      id\n    }));\n  }).catch(error => {\n    error.clientMessage = \"Can't delete remark\";\n    dispatch(actions.catchError({\n      error,\n      callType: callTypes.action\n    }));\n  });\n};\nexport const createRemark = remarkForCreation => dispatch => {\n  dispatch(actions.startCall({\n    callType: callTypes.action\n  }));\n  return requestFromServer.createRemark(remarkForCreation).then(response => {\n    const {\n      remark\n    } = response.data;\n    dispatch(actions.remarkCreated({\n      remark\n    }));\n  }).catch(error => {\n    error.clientMessage = \"Can't create remark\";\n    dispatch(actions.catchError({\n      error,\n      callType: callTypes.action\n    }));\n  });\n};\nexport const updateRemark = remark => dispatch => {\n  dispatch(actions.startCall({\n    callType: callTypes.action\n  }));\n  return requestFromServer.updateRemark(remark).then(() => {\n    dispatch(actions.remarkUpdated({\n      remark\n    }));\n  }).catch(error => {\n    error.clientMessage = \"Can't update remark\";\n    dispatch(actions.catchError({\n      error,\n      callType: callTypes.action\n    }));\n  });\n};\nexport const deleteRemarks = ids => dispatch => {\n  dispatch(actions.startCall({\n    callType: callTypes.action\n  }));\n  return requestFromServer.deleteRemarks(ids).then(() => {\n    console.log(\"delete return\");\n    dispatch(actions.remarksDeleted({\n      ids\n    }));\n  }).catch(error => {\n    error.clientMessage = \"Can't delete remarks\";\n    dispatch(actions.catchError({\n      error,\n      callType: callTypes.action\n    }));\n  });\n};","map":{"version":3,"sources":["/home/khatnaa/Desktop/project/src/app/modules/ECommerce/_redux/remarks/remarksActions.tsx"],"names":["requestFromServer","remarksSlice","callTypes","actions","fetchRemarks","queryParams","productId","dispatch","startCall","callType","list","remarksFetched","totalCount","entities","findRemarks","then","response","data","catch","error","clientMessage","catchError","fetchRemark","id","remarkFetched","remarkForEdit","undefined","action","getRemarkById","remark","deleteRemark","remarkDeleted","createRemark","remarkForCreation","remarkCreated","updateRemark","remarkUpdated","deleteRemarks","ids","console","log","remarksDeleted"],"mappings":"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","sourcesContent":["import * as requestFromServer from \"./remarksCrud\";\r\nimport {remarksSlice, callTypes} from \"./remarksSlice\";\r\n\r\nconst {actions} = remarksSlice;\r\n\r\nexport const fetchRemarks = (queryParams: any, productId: any) => {\r\n  return (dispatch: (arg0: { payload: any; type: string; }) => void) => {\r\n    dispatch(actions.startCall({ callType: callTypes.list }));\r\n    if (!productId) {\r\n      return dispatch(actions.remarksFetched({ totalCount: 0, entities: null }));\r\n    }\r\n\r\n    return requestFromServer\r\n      .findRemarks(queryParams, productId)\r\n      .then(response => {\r\n        const { totalCount, entities } = response.data;\r\n        dispatch(actions.remarksFetched({ totalCount, entities }));\r\n      })\r\n      .catch(error => {\r\n        error.clientMessage = \"Can't find remarks\";\r\n        dispatch(actions.catchError({ error, callType: callTypes.list }));\r\n      });\r\n  };\r\n};\r\n\r\nexport const fetchRemark = (id: any) => (dispatch: (arg0: { payload: any; type: string; }) => void) => {\r\n  if (!id) {\r\n    return dispatch(actions.remarkFetched({ remarkForEdit: undefined }));\r\n  }\r\n\r\n  dispatch(actions.startCall({ callType: callTypes.action }));\r\n  return requestFromServer\r\n    .getRemarkById(id)\r\n    .then(response => {\r\n      const remark = response.data;\r\n      dispatch(actions.remarkFetched({ remarkForEdit: remark }));\r\n    })\r\n    .catch(error => {\r\n      error.clientMessage = \"Can't find remark\";\r\n      dispatch(actions.catchError({ error, callType: callTypes.action }));\r\n    });\r\n};\r\n\r\nexport const deleteRemark = (id: any) => (dispatch: (arg0: { payload: any; type: string; }) => void) => {\r\n  dispatch(actions.startCall({ callType: callTypes.action }));\r\n  return requestFromServer\r\n    .deleteRemark(id)\r\n    .then(response => {\r\n      dispatch(actions.remarkDeleted({ id }));\r\n    })\r\n    .catch(error => {\r\n      error.clientMessage = \"Can't delete remark\";\r\n      dispatch(actions.catchError({ error, callType: callTypes.action }));\r\n    });\r\n};\r\n\r\nexport const createRemark = (remarkForCreation: any) => (dispatch: (arg0: { payload: any; type: string; }) => void) => {\r\n  dispatch(actions.startCall({ callType: callTypes.action }));\r\n  return requestFromServer\r\n    .createRemark(remarkForCreation)\r\n    .then(response => {\r\n      const { remark } = response.data;\r\n      dispatch(actions.remarkCreated({ remark }));\r\n    })\r\n    .catch(error => {\r\n      error.clientMessage = \"Can't create remark\";\r\n      dispatch(actions.catchError({ error, callType: callTypes.action }));\r\n    });\r\n};\r\n\r\nexport const updateRemark = (remark: any) => (dispatch: (arg0: { payload: any; type: string; }) => void) => {\r\n  dispatch(actions.startCall({ callType: callTypes.action }));\r\n  return requestFromServer\r\n    .updateRemark(remark)\r\n    .then(() => {\r\n      dispatch(actions.remarkUpdated({ remark }));\r\n    })\r\n    .catch(error => {\r\n      error.clientMessage = \"Can't update remark\";\r\n      dispatch(actions.catchError({ error, callType: callTypes.action }));\r\n    });\r\n};\r\n\r\nexport const deleteRemarks = (ids: any) => (dispatch: (arg0: { payload: any; type: string; }) => void) => {\r\n  dispatch(actions.startCall({ callType: callTypes.action }));\r\n  return requestFromServer\r\n    .deleteRemarks(ids)\r\n    .then(() => {\r\n      console.log(\"delete return\");\r\n      dispatch(actions.remarksDeleted({ ids }));\r\n    })\r\n    .catch(error => {\r\n      error.clientMessage = \"Can't delete remarks\";\r\n      dispatch(actions.catchError({ error, callType: callTypes.action }));\r\n    });\r\n};\r\n"]},"metadata":{},"sourceType":"module"}